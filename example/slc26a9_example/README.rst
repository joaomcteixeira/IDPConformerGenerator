Modelling Disordered Regions Within a Chain Break
=================================================

.. start-description

The following example will walk you through building an 86 AA IDR to close the chain break.
You should already be familiar with LDRS Local Disordered Region Sampling (LDRS ``ldrs`` subclient).

For this exercise, we will be constructing the intrinsically disordered region from residues 49-135 on
the STAS domain of SLC26A9 (PDB ID 7CH1). Please enter the example :code:`example/slc26a9_example` folder
where you will find the complete FASTA sequence: ``SLC26A9_STAS.fasta``, and a PDB of the
folded region from PDB ID 4GMJ: ``7CH1_SLC26A9.pdb``.

.. note::
    The next-seeker protocol for completing a chain closure may take awhile depending on various factors
    such as: length of IDR to model, distance between the chain break, location of the chain break (e.g.
    are there folded domains that eliminate some paths to close the break).

    Due to the modularity of LDRS, a more efficient method that requires some Python scripting knowledge is
    described below in the **Advanced LDRS Usage** section.

Steps from now will assume you're in the working director of ``example/slc26a9_example``
and have already compiled your preferred reusable IDPConformerGenerator database. For
instructions on the database, please visit the previous exercise "A Real Case Scenario".

We will be using the ``ldrs`` subclient to model 50 conformations of the
intrinsically disordered region like so::

    idpconfgen ldrs \
        -db <PATH TO DATABASE.JSON> \
        -seq slc26a9_example.fasta \
        -etbb 100 \
        -etss 250 \
        -nc 50 \
        --dloop-off \
        --dany \
        -fld 7CH1_SLC26A9.pdb \
        -of ./slc26a9_ldrs_ANY_faspr \
        -n

The ``ldrs`` subclient can handle N-IDR, C-IDR and any number of Break-IDR cases automatically.

Advanced LDRS Usage
-------------------

The logic behind LDRS for "filling in" a broken chain with an IDR assumes that we have
an N-IDR like case at the C-terminal region of the chain break and a C-IDR like case at the
N-terminal region of the chain break. Thus, our IDR that we need to model needs to have 2 residue
overhangs on either side that overlaps with 2 residues on the folded protein on either side of the break.

A sequence has already been prepared ``SLC26A9_IDR.fasta`` for this case in the example folder.
Here is a brief overview of what we will do to speed-up the process of closing the chain break
with and all-atom IDR model:

#. Generate 10,000 structures (more = better sampling) of the IDR backbone only:

    .. code-block:: bash
        idpconfgen build \
            -db <PATH TO DATABASE.JSON> \
            -seq SLC26A9_IDR.fasta \
            -etbb 100 \
            -dsd \
            -nc 10000 \
            --dloop-off \
            --dany \
            -of ./slc26a9_idr_ANY_bb \
            -n

#. Create the necessary folders for the script to run:

    .. code-block:: bash
        mkdir slc26a9_cterm
        mkdir slc26a9_nterm
        mkdir slc26a9_matches
        mkdir slc26a9_sidechains
        mkdir slc26a9_results

#. Change the paths in the script ``slc26a9_shortcut.py`` and run it while the ``idpconfgen`` environment is active.
#. Attach sidechains onto the conformers generated by the next-seeker protocol in the ``matches`` folder using MC-SCE:

    .. code-block:: bash
        mcsce ./slc26a9_matches 64 -w -s -o ./slc26a9_sidechains -l ./mcsce_log

#. Use ``psurgeon()`` in ``slc26a9_stitching.py`` script to attach the all-atom IDR models to the folded domain.

The idea here is to have IDPConformerGenerator generate a large library of IDPs that may represent the IDR
in question. We are exploting IDPConformerGenerator's speed and diversity for generating conformers. The time
rate-limiting step here is the next-seeker protocol where we have to compare all of the structures in
``slc26a9_cterm`` to all structures in ``slc26a9_nterm`` to find our candidates for sidechain addition.

To further save time, especially on a computing cluster, is to either split the conformers in the ``cterm`` and
``nterm`` folder to run jobs in parallel or request more workers. Please note that this shortcut is not a memory
intensive task so 8 GB of RAM is more than sufficient to run the next-seeker protocol.

.. end-description
